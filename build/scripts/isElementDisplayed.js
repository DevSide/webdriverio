"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isElementDisplayed;

require("source-map-support/register");

/*
 * Copyright (C) 2017 Apple Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS''
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * check if element is visible
 * @param  {HTMLElement} elem  element to check
 * @return {Boolean}           true if element is within viewport
 */
function isElementDisplayed(element) {
  function nodeIsElement(node) {
    if (!node) return false;

    switch (node.nodeType) {
      case Node.ELEMENT_NODE:
      case Node.DOCUMENT_NODE:
      case Node.DOCUMENT_FRAGMENT_NODE:
        return true;

      default:
        return false;
    }
  }

  function parentElementForElement(element) {
    if (!element) return null;
    return enclosingNodeOrSelfMatchingPredicate(element.parentNode, nodeIsElement);
  }

  function enclosingNodeOrSelfMatchingPredicate(targetNode, predicate) {
    for (let node = targetNode; node && node !== targetNode.ownerDocument; node = node.parentNode) if (predicate(node)) return node;

    return null;
  }

  function enclosingElementOrSelfMatchingPredicate(targetElement, predicate) {
    for (let element = targetElement; element && element !== targetElement.ownerDocument; element = parentElementForElement(element)) if (predicate(element)) return element;

    return null;
  }

  function cascadedStylePropertyForElement(element, property) {
    if (!element || !property) return null;
    let computedStyle = window.getComputedStyle(element);
    let computedStyleProperty = computedStyle.getPropertyValue(property);
    if (computedStyleProperty && computedStyleProperty !== 'inherit') return computedStyleProperty; // Ideally getPropertyValue would return the 'used' or 'actual' value, but
    // it doesn't for legacy reasons. So we need to do our own poor man's cascade.
    // Fall back to the first non-'inherit' value found in an ancestor.
    // In any case, getPropertyValue will not return 'initial'.
    // FIXME: will this incorrectly inherit non-inheritable CSS properties?
    // I think all important non-inheritable properties (width, height, etc.)
    // for our purposes here are specially resolved, so this may not be an issue.
    // Specification is here: https://drafts.csswg.org/cssom/#resolved-values

    let parentElement = parentElementForElement(element);
    return cascadedStylePropertyForElement(parentElement, property);
  }

  function elementSubtreeHasNonZeroDimensions(element) {
    let boundingBox = element.getBoundingClientRect();
    if (boundingBox.width > 0 && boundingBox.height > 0) return true; // Paths can have a zero width or height. Treat them as shown if the stroke width is positive.

    if (element.tagName.toUpperCase() === 'PATH' && boundingBox.width + boundingBox.height > 0) {
      let strokeWidth = cascadedStylePropertyForElement(element, 'stroke-width');
      return !!strokeWidth && parseInt(strokeWidth, 10) > 0;
    }

    let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');
    if (cascadedOverflow === 'hidden') return false; // If the container's overflow is not hidden and it has zero size, consider the
    // container to have non-zero dimensions if a child node has non-zero dimensions.

    return Array.from(element.childNodes).some(childNode => {
      if (childNode.nodeType === Node.TEXT_NODE) return true;
      if (nodeIsElement(childNode)) return elementSubtreeHasNonZeroDimensions(childNode);
      return false;
    });
  }

  function elementOverflowsContainer(element) {
    let cascadedOverflow = cascadedStylePropertyForElement(element, 'overflow');
    if (cascadedOverflow !== 'hidden') return false; // FIXME: this needs to take into account the scroll position of the element,
    // the display modes of it and its ancestors, and the container it overflows.
    // See Selenium's bot.dom.getOverflowState atom for an exhaustive list of edge cases.

    return true;
  }

  function isElementSubtreeHiddenByOverflow(element) {
    if (!element) return false;
    if (!elementOverflowsContainer(element)) return false; // This element's subtree is hidden by overflow if all child subtrees are as well.

    return Array.from(element.childNodes).every(childNode => {
      // Returns true if the child node is overflowed or otherwise hidden.
      // Base case: not an element, has zero size, scrolled out, or doesn't overflow container.
      if (!nodeIsElement(childNode)) return true;
      if (!elementSubtreeHasNonZeroDimensions(childNode)) return true; // Recurse.

      return isElementSubtreeHiddenByOverflow(childNode);
    });
  } // This is a partial reimplementation of Selenium's "element is displayed" algorithm.
  // When the W3C specification's algorithm stabilizes, we should implement that.
  // If this command is misdirected to the wrong document, treat it as not shown.


  if (!document.contains(element)) return false; // Special cases for specific tag names.

  switch (element.tagName.toUpperCase()) {
    case 'BODY':
      return true;

    case 'SCRIPT':
    case 'NOSCRIPT':
      return false;

    case 'OPTGROUP':
    case 'OPTION':
      {
        // Option/optgroup are considered shown if the containing <select> is shown.
        let enclosingSelectElement = enclosingNodeOrSelfMatchingPredicate(element, e => e.tagName.toUpperCase() === 'SELECT');
        return isElementDisplayed(enclosingSelectElement);
      }

    case 'INPUT':
      // <input type="hidden"> is considered not shown.
      if (element.type === 'hidden') return false;
      break;
    // case 'MAP':
    // FIXME: Selenium has special handling for <map> elements. We don't do anything now.

    default:
      break;
  }

  if (cascadedStylePropertyForElement(element, 'visibility') !== 'visible') return false;
  let hasAncestorWithZeroOpacity = !!enclosingElementOrSelfMatchingPredicate(element, e => {
    return Number(cascadedStylePropertyForElement(e, 'opacity')) === 0;
  });
  let hasAncestorWithDisplayNone = !!enclosingElementOrSelfMatchingPredicate(element, e => {
    return cascadedStylePropertyForElement(e, 'display') === 'none';
  });
  if (hasAncestorWithZeroOpacity || hasAncestorWithDisplayNone) return false;
  if (!elementSubtreeHasNonZeroDimensions(element)) return false;
  if (isElementSubtreeHiddenByOverflow(element)) return false;
  return true;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zY3JpcHRzL2lzRWxlbWVudERpc3BsYXllZC5qcyJdLCJuYW1lcyI6WyJpc0VsZW1lbnREaXNwbGF5ZWQiLCJlbGVtZW50Iiwibm9kZUlzRWxlbWVudCIsIm5vZGUiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJET0NVTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsInBhcmVudEVsZW1lbnRGb3JFbGVtZW50IiwiZW5jbG9zaW5nTm9kZU9yU2VsZk1hdGNoaW5nUHJlZGljYXRlIiwicGFyZW50Tm9kZSIsInRhcmdldE5vZGUiLCJwcmVkaWNhdGUiLCJvd25lckRvY3VtZW50IiwiZW5jbG9zaW5nRWxlbWVudE9yU2VsZk1hdGNoaW5nUHJlZGljYXRlIiwidGFyZ2V0RWxlbWVudCIsImNhc2NhZGVkU3R5bGVQcm9wZXJ0eUZvckVsZW1lbnQiLCJwcm9wZXJ0eSIsImNvbXB1dGVkU3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiY29tcHV0ZWRTdHlsZVByb3BlcnR5IiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBhcmVudEVsZW1lbnQiLCJlbGVtZW50U3VidHJlZUhhc05vblplcm9EaW1lbnNpb25zIiwiYm91bmRpbmdCb3giLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInRhZ05hbWUiLCJ0b1VwcGVyQ2FzZSIsInN0cm9rZVdpZHRoIiwicGFyc2VJbnQiLCJjYXNjYWRlZE92ZXJmbG93IiwiQXJyYXkiLCJmcm9tIiwiY2hpbGROb2RlcyIsInNvbWUiLCJjaGlsZE5vZGUiLCJURVhUX05PREUiLCJlbGVtZW50T3ZlcmZsb3dzQ29udGFpbmVyIiwiaXNFbGVtZW50U3VidHJlZUhpZGRlbkJ5T3ZlcmZsb3ciLCJldmVyeSIsImRvY3VtZW50IiwiY29udGFpbnMiLCJlbmNsb3NpbmdTZWxlY3RFbGVtZW50IiwiZSIsInR5cGUiLCJoYXNBbmNlc3RvcldpdGhaZXJvT3Bh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QWpFO0FBQ0gsR0FGeUUsQ0FBMUU7QUFHQSxNQUFJSSwwQkFBMEIsR0FBRyxDQUFDLENBQUNwQyx1Q0FBdUMsQ0FBQ2QsT0FBRCxFQUFXOEMsQ0FBRCxJQUFPO0FBQ3ZGLFdBQU85QiwrQkFBK0IsQ0FBQzhCLENBQUQsRUFBSSxTQUFKLENBQS9CLEtBQWtELE1BQXpEO0FBQ0gsR0FGeUUsQ0FBMUU7QUFHQSxNQUFJRSwwQkFBMEIsSUFBSUUsMEJBQWxDLEVBQ0ksT0FBTyxLQUFQO0FBRUosTUFBSSxDQUFDMUIsa0NBQWtDLENBQUN4QixPQUFELENBQXZDLEVBQ0ksT0FBTyxLQUFQO0FBRUosTUFBSXlDLGdDQUFnQyxDQUFDekMsT0FBRCxDQUFwQyxFQUNJLE9BQU8sS0FBUDtBQUVKLFNBQU8sSUFBUDtBQUNIIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIENvcHlyaWdodCAoQykgMjAxNyBBcHBsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIEFORCBJVFMgQ09OVFJJQlVUT1JTIGBgQVMgSVMnJ1xuICogQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBBUFBMRSBJTkMuIE9SIElUUyBDT05UUklCVVRPUlNcbiAqIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1JcbiAqIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GXG4gKiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1NcbiAqIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOXG4gKiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKVxuICogQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRlxuICogVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qKlxuICogY2hlY2sgaWYgZWxlbWVudCBpcyB2aXNpYmxlXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxlbSAgZWxlbWVudCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgIHRydWUgaWYgZWxlbWVudCBpcyB3aXRoaW4gdmlld3BvcnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNFbGVtZW50RGlzcGxheWVkKGVsZW1lbnQpIHtcbiAgICBmdW5jdGlvbiBub2RlSXNFbGVtZW50KG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9OT0RFOlxuICAgICAgICBjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyZW50RWxlbWVudEZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbFxuXG4gICAgICAgIHJldHVybiBlbmNsb3NpbmdOb2RlT3JTZWxmTWF0Y2hpbmdQcmVkaWNhdGUoZWxlbWVudC5wYXJlbnROb2RlLCBub2RlSXNFbGVtZW50KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuY2xvc2luZ05vZGVPclNlbGZNYXRjaGluZ1ByZWRpY2F0ZSh0YXJnZXROb2RlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRhcmdldE5vZGU7IG5vZGUgJiYgbm9kZSAhPT0gdGFyZ2V0Tm9kZS5vd25lckRvY3VtZW50OyBub2RlID0gbm9kZS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZVxuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jbG9zaW5nRWxlbWVudE9yU2VsZk1hdGNoaW5nUHJlZGljYXRlKHRhcmdldEVsZW1lbnQsIHByZWRpY2F0ZSkge1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudDsgZWxlbWVudCAmJiBlbGVtZW50ICE9PSB0YXJnZXRFbGVtZW50Lm93bmVyRG9jdW1lbnQ7IGVsZW1lbnQgPSBwYXJlbnRFbGVtZW50Rm9yRWxlbWVudChlbGVtZW50KSlcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRcblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhc2NhZGVkU3R5bGVQcm9wZXJ0eUZvckVsZW1lbnQoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFwcm9wZXJ0eSlcbiAgICAgICAgICAgIHJldHVybiBudWxsXG5cbiAgICAgICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVxuICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZVByb3BlcnR5ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZVByb3BlcnR5ICYmIGNvbXB1dGVkU3R5bGVQcm9wZXJ0eSAhPT0gJ2luaGVyaXQnKVxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVkU3R5bGVQcm9wZXJ0eVxuXG4gICAgICAgIC8vIElkZWFsbHkgZ2V0UHJvcGVydHlWYWx1ZSB3b3VsZCByZXR1cm4gdGhlICd1c2VkJyBvciAnYWN0dWFsJyB2YWx1ZSwgYnV0XG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgZm9yIGxlZ2FjeSByZWFzb25zLiBTbyB3ZSBuZWVkIHRvIGRvIG91ciBvd24gcG9vciBtYW4ncyBjYXNjYWRlLlxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gdGhlIGZpcnN0IG5vbi0naW5oZXJpdCcgdmFsdWUgZm91bmQgaW4gYW4gYW5jZXN0b3IuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCBnZXRQcm9wZXJ0eVZhbHVlIHdpbGwgbm90IHJldHVybiAnaW5pdGlhbCcuXG5cbiAgICAgICAgLy8gRklYTUU6IHdpbGwgdGhpcyBpbmNvcnJlY3RseSBpbmhlcml0IG5vbi1pbmhlcml0YWJsZSBDU1MgcHJvcGVydGllcz9cbiAgICAgICAgLy8gSSB0aGluayBhbGwgaW1wb3J0YW50IG5vbi1pbmhlcml0YWJsZSBwcm9wZXJ0aWVzICh3aWR0aCwgaGVpZ2h0LCBldGMuKVxuICAgICAgICAvLyBmb3Igb3VyIHB1cnBvc2VzIGhlcmUgYXJlIHNwZWNpYWxseSByZXNvbHZlZCwgc28gdGhpcyBtYXkgbm90IGJlIGFuIGlzc3VlLlxuICAgICAgICAvLyBTcGVjaWZpY2F0aW9uIGlzIGhlcmU6IGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG4gICAgICAgIGxldCBwYXJlbnRFbGVtZW50ID0gcGFyZW50RWxlbWVudEZvckVsZW1lbnQoZWxlbWVudClcbiAgICAgICAgcmV0dXJuIGNhc2NhZGVkU3R5bGVQcm9wZXJ0eUZvckVsZW1lbnQocGFyZW50RWxlbWVudCwgcHJvcGVydHkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxlbWVudFN1YnRyZWVIYXNOb25aZXJvRGltZW5zaW9ucyhlbGVtZW50KSB7XG4gICAgICAgIGxldCBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgaWYgKGJvdW5kaW5nQm94LndpZHRoID4gMCAmJiBib3VuZGluZ0JveC5oZWlnaHQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAvLyBQYXRocyBjYW4gaGF2ZSBhIHplcm8gd2lkdGggb3IgaGVpZ2h0LiBUcmVhdCB0aGVtIGFzIHNob3duIGlmIHRoZSBzdHJva2Ugd2lkdGggaXMgcG9zaXRpdmUuXG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1BBVEgnICYmIGJvdW5kaW5nQm94LndpZHRoICsgYm91bmRpbmdCb3guaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgbGV0IHN0cm9rZVdpZHRoID0gY2FzY2FkZWRTdHlsZVByb3BlcnR5Rm9yRWxlbWVudChlbGVtZW50LCAnc3Ryb2tlLXdpZHRoJylcbiAgICAgICAgICAgIHJldHVybiAhIXN0cm9rZVdpZHRoICYmIChwYXJzZUludChzdHJva2VXaWR0aCwgMTApID4gMClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjYXNjYWRlZE92ZXJmbG93ID0gY2FzY2FkZWRTdHlsZVByb3BlcnR5Rm9yRWxlbWVudChlbGVtZW50LCAnb3ZlcmZsb3cnKVxuICAgICAgICBpZiAoY2FzY2FkZWRPdmVyZmxvdyA9PT0gJ2hpZGRlbicpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyJ3Mgb3ZlcmZsb3cgaXMgbm90IGhpZGRlbiBhbmQgaXQgaGFzIHplcm8gc2l6ZSwgY29uc2lkZXIgdGhlXG4gICAgICAgIC8vIGNvbnRhaW5lciB0byBoYXZlIG5vbi16ZXJvIGRpbWVuc2lvbnMgaWYgYSBjaGlsZCBub2RlIGhhcyBub24temVybyBkaW1lbnNpb25zLlxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpLnNvbWUoKGNoaWxkTm9kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgaWYgKG5vZGVJc0VsZW1lbnQoY2hpbGROb2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudFN1YnRyZWVIYXNOb25aZXJvRGltZW5zaW9ucyhjaGlsZE5vZGUpXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVsZW1lbnRPdmVyZmxvd3NDb250YWluZXIoZWxlbWVudCkge1xuICAgICAgICBsZXQgY2FzY2FkZWRPdmVyZmxvdyA9IGNhc2NhZGVkU3R5bGVQcm9wZXJ0eUZvckVsZW1lbnQoZWxlbWVudCwgJ292ZXJmbG93JylcbiAgICAgICAgaWYgKGNhc2NhZGVkT3ZlcmZsb3cgIT09ICdoaWRkZW4nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgLy8gRklYTUU6IHRoaXMgbmVlZHMgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgICAgLy8gdGhlIGRpc3BsYXkgbW9kZXMgb2YgaXQgYW5kIGl0cyBhbmNlc3RvcnMsIGFuZCB0aGUgY29udGFpbmVyIGl0IG92ZXJmbG93cy5cbiAgICAgICAgLy8gU2VlIFNlbGVuaXVtJ3MgYm90LmRvbS5nZXRPdmVyZmxvd1N0YXRlIGF0b20gZm9yIGFuIGV4aGF1c3RpdmUgbGlzdCBvZiBlZGdlIGNhc2VzLlxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRWxlbWVudFN1YnRyZWVIaWRkZW5CeU92ZXJmbG93KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFlbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgaWYgKCFlbGVtZW50T3ZlcmZsb3dzQ29udGFpbmVyKGVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgLy8gVGhpcyBlbGVtZW50J3Mgc3VidHJlZSBpcyBoaWRkZW4gYnkgb3ZlcmZsb3cgaWYgYWxsIGNoaWxkIHN1YnRyZWVzIGFyZSBhcyB3ZWxsLlxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50LmNoaWxkTm9kZXMpLmV2ZXJ5KChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2hpbGQgbm9kZSBpcyBvdmVyZmxvd2VkIG9yIG90aGVyd2lzZSBoaWRkZW4uXG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IG5vdCBhbiBlbGVtZW50LCBoYXMgemVybyBzaXplLCBzY3JvbGxlZCBvdXQsIG9yIGRvZXNuJ3Qgb3ZlcmZsb3cgY29udGFpbmVyLlxuICAgICAgICAgICAgaWYgKCFub2RlSXNFbGVtZW50KGNoaWxkTm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgaWYgKCFlbGVtZW50U3VidHJlZUhhc05vblplcm9EaW1lbnNpb25zKGNoaWxkTm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcblxuICAgICAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgICAgIHJldHVybiBpc0VsZW1lbnRTdWJ0cmVlSGlkZGVuQnlPdmVyZmxvdyhjaGlsZE5vZGUpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBhIHBhcnRpYWwgcmVpbXBsZW1lbnRhdGlvbiBvZiBTZWxlbml1bSdzIFwiZWxlbWVudCBpcyBkaXNwbGF5ZWRcIiBhbGdvcml0aG0uXG4gICAgLy8gV2hlbiB0aGUgVzNDIHNwZWNpZmljYXRpb24ncyBhbGdvcml0aG0gc3RhYmlsaXplcywgd2Ugc2hvdWxkIGltcGxlbWVudCB0aGF0LlxuXG4gICAgLy8gSWYgdGhpcyBjb21tYW5kIGlzIG1pc2RpcmVjdGVkIHRvIHRoZSB3cm9uZyBkb2N1bWVudCwgdHJlYXQgaXQgYXMgbm90IHNob3duLlxuICAgIGlmICghZG9jdW1lbnQuY29udGFpbnMoZWxlbWVudCkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlcyBmb3Igc3BlY2lmaWMgdGFnIG5hbWVzLlxuICAgIHN3aXRjaCAoZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgICAgcmV0dXJuIHRydWVcblxuICAgIGNhc2UgJ1NDUklQVCc6XG4gICAgY2FzZSAnTk9TQ1JJUFQnOlxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIGNhc2UgJ09QVEdST1VQJzpcbiAgICBjYXNlICdPUFRJT04nOiB7XG4gICAgICAgIC8vIE9wdGlvbi9vcHRncm91cCBhcmUgY29uc2lkZXJlZCBzaG93biBpZiB0aGUgY29udGFpbmluZyA8c2VsZWN0PiBpcyBzaG93bi5cbiAgICAgICAgbGV0IGVuY2xvc2luZ1NlbGVjdEVsZW1lbnQgPSBlbmNsb3NpbmdOb2RlT3JTZWxmTWF0Y2hpbmdQcmVkaWNhdGUoZWxlbWVudCwgKGUpID0+IGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnU0VMRUNUJylcbiAgICAgICAgcmV0dXJuIGlzRWxlbWVudERpc3BsYXllZChlbmNsb3NpbmdTZWxlY3RFbGVtZW50KVxuICAgIH1cbiAgICBjYXNlICdJTlBVVCc6XG4gICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+IGlzIGNvbnNpZGVyZWQgbm90IHNob3duLlxuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSAnaGlkZGVuJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICBicmVha1xuICAgICAgICAvLyBjYXNlICdNQVAnOlxuICAgICAgICAvLyBGSVhNRTogU2VsZW5pdW0gaGFzIHNwZWNpYWwgaGFuZGxpbmcgZm9yIDxtYXA+IGVsZW1lbnRzLiBXZSBkb24ndCBkbyBhbnl0aGluZyBub3cuXG5cbiAgICBkZWZhdWx0OlxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGlmIChjYXNjYWRlZFN0eWxlUHJvcGVydHlGb3JFbGVtZW50KGVsZW1lbnQsICd2aXNpYmlsaXR5JykgIT09ICd2aXNpYmxlJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBsZXQgaGFzQW5jZXN0b3JXaXRoWmVyb09wYWNpdHkgPSAhIWVuY2xvc2luZ0VsZW1lbnRPclNlbGZNYXRjaGluZ1ByZWRpY2F0ZShlbGVtZW50LCAoZSkgPT4ge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGNhc2NhZGVkU3R5bGVQcm9wZXJ0eUZvckVsZW1lbnQoZSwgJ29wYWNpdHknKSkgPT09IDBcbiAgICB9KVxuICAgIGxldCBoYXNBbmNlc3RvcldpdGhEaXNwbGF5Tm9uZSA9ICEhZW5jbG9zaW5nRWxlbWVudE9yU2VsZk1hdGNoaW5nUHJlZGljYXRlKGVsZW1lbnQsIChlKSA9PiB7XG4gICAgICAgIHJldHVybiBjYXNjYWRlZFN0eWxlUHJvcGVydHlGb3JFbGVtZW50KGUsICdkaXNwbGF5JykgPT09ICdub25lJ1xuICAgIH0pXG4gICAgaWYgKGhhc0FuY2VzdG9yV2l0aFplcm9PcGFjaXR5IHx8IGhhc0FuY2VzdG9yV2l0aERpc3BsYXlOb25lKVxuICAgICAgICByZXR1cm4gZmFsc2VcblxuICAgIGlmICghZWxlbWVudFN1YnRyZWVIYXNOb25aZXJvRGltZW5zaW9ucyhlbGVtZW50KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlXG5cbiAgICBpZiAoaXNFbGVtZW50U3VidHJlZUhpZGRlbkJ5T3ZlcmZsb3coZWxlbWVudCkpXG4gICAgICAgIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIHRydWVcbn1cbiJdfQ==